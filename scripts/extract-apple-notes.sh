#!/bin/bash
# ============================================================
# APPLE NOTES EXTRACTION SCRIPT
# READ-ONLY extraction + tag append (#claudewashere)
# NO DELETE. NO MOVE. SAFE.
# Compatible with macOS bash 3.2 (no associative arrays)
# ============================================================

set -uo pipefail

TIMESTAMP=$(date +"%Y%m%d_%H%M%S")
OUTPUT_MD="$HOME/Desktop/APPLE_NOTES_EXTRACTION_${TIMESTAMP}.md"
OUTPUT_CSV="$HOME/Desktop/APPLE_NOTES_EXTRACTION_${TIMESTAMP}.csv"
LOG="/tmp/apple-notes-extraction.log"
SEPARATOR="$(printf '=%.0s' $(seq 1 35))"

# Counters (bash 3.2 compatible — no associative arrays)
TOTAL=0
COUNT_CAPTION=0
COUNT_QUOTE=0
COUNT_BOOK_DRAFT=0
COUNT_POEM=0
COUNT_IDEA=0
COUNT_EMAIL=0
COUNT_CONTENT=0
SKIPPED=0
ERRORS=0

log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" | tee -a "$LOG"
}

classify_note() {
    local title="$1"
    local body="$2"
    local combined
    combined=$(printf '%s %s' "$title" "$body" | tr '[:upper:]' '[:lower:]')

    if echo "$combined" | grep -qiE '#caption|#captions'; then
        echo "CAPTION"
    elif echo "$combined" | grep -qiE '#quote'; then
        echo "QUOTE"
    elif echo "$combined" | grep -qiE '#book|#writing|book draft|chapter'; then
        echo "BOOK_DRAFT"
    elif echo "$combined" | grep -qiE '#poem'; then
        echo "POEM"
    elif echo "$combined" | grep -qiE '#idea'; then
        echo "IDEA"
    elif echo "$combined" | grep -qiE '#email|email draft'; then
        echo "EMAIL"
    else
        echo "CONTENT"
    fi
}

increment_type() {
    case "$1" in
        CAPTION)    COUNT_CAPTION=$((COUNT_CAPTION + 1)) ;;
        QUOTE)      COUNT_QUOTE=$((COUNT_QUOTE + 1)) ;;
        BOOK_DRAFT) COUNT_BOOK_DRAFT=$((COUNT_BOOK_DRAFT + 1)) ;;
        POEM)       COUNT_POEM=$((COUNT_POEM + 1)) ;;
        IDEA)       COUNT_IDEA=$((COUNT_IDEA + 1)) ;;
        EMAIL)      COUNT_EMAIL=$((COUNT_EMAIL + 1)) ;;
        CONTENT)    COUNT_CONTENT=$((COUNT_CONTENT + 1)) ;;
    esac
}

escape_csv() {
    local val="$1"
    val="${val//\"/\"\"}"
    printf '"%s"' "$val"
}

# ============================================================
# INIT
# ============================================================
> "$LOG"
log "=========================================="
log "APPLE NOTES EXTRACTION STARTED"
log "=========================================="
log "Output MD: $OUTPUT_MD"
log "Output CSV: $OUTPUT_CSV"

# Write MD header
cat > "$OUTPUT_MD" << 'HEADER'
# APPLE NOTES EXTRACTION
# Generated by extract-apple-notes.sh
# READ-ONLY extraction -- no notes were deleted or moved
# Notes tagged with #claudewashere after extraction

HEADER

# Write CSV header
echo "type,title,date,content_preview,full_content" > "$OUTPUT_CSV"

# ============================================================
# STEP 1: Get all folder names
# ============================================================
log "Getting folder list..."

FOLDERS=$(osascript << 'APPLESCRIPT'
tell application "Notes"
    set folderList to {}
    repeat with f in folders
        set end of folderList to name of f
    end repeat
    set AppleScript's text item delimiters to "<<FOLDER_SEP>>"
    return folderList as text
end tell
APPLESCRIPT
) || { log "FATAL: Could not access Apple Notes"; exit 1; }

# Split on delimiter
IFS=$'\n' read -d '' -ra FOLDER_ARRAY < <(echo "$FOLDERS" | sed 's/<<FOLDER_SEP>>/\n/g') || true
log "Found ${#FOLDER_ARRAY[@]} folders"

# ============================================================
# STEP 2: Process each folder
# ============================================================
for folder_name in "${FOLDER_ARRAY[@]}"; do
    # Skip empty entries
    [ -z "$folder_name" ] && continue

    log "Processing folder: $folder_name"

    # Get note count in this folder
    NOTE_COUNT=$(osascript -e "
        tell application \"Notes\"
            try
                set f to folder \"$folder_name\"
                return count of notes of f
            on error
                return 0
            end try
        end tell
    " 2>/dev/null || echo "0")

    log "  Notes in '$folder_name': $NOTE_COUNT"

    if [ "$NOTE_COUNT" = "0" ] || [ -z "$NOTE_COUNT" ]; then
        continue
    fi

    # Process each note by index
    i=1
    while [ $i -le "$NOTE_COUNT" ]; do
        log "  Processing note $i of $NOTE_COUNT in '$folder_name'..."

        # Get note data via osascript — use temp file for large notes
        TMPFILE=$(mktemp /tmp/apple_note_XXXXXX)
        osascript << ENDSCRIPT > "$TMPFILE" 2>/dev/null
            tell application "Notes"
                try
                    set f to folder "$folder_name"
                    set n to note $i of f
                    set noteName to name of n
                    set noteBody to plaintext of n
                    set noteDate to modification date of n as string
                    return noteName & "<<FIELD_SEP>>" & noteBody & "<<FIELD_SEP>>" & noteDate
                on error errMsg
                    return "<<ERROR>>" & errMsg
                end try
            end tell
ENDSCRIPT

        NOTE_DATA=$(cat "$TMPFILE")
        rm -f "$TMPFILE"

        # Check for error
        if echo "$NOTE_DATA" | grep -q "<<ERROR>>"; then
            log "  WARNING: Error reading note $i in '$folder_name': $NOTE_DATA"
            ERRORS=$((ERRORS + 1))
            i=$((i + 1))
            continue
        fi

        if [ -z "$NOTE_DATA" ]; then
            log "  WARNING: Empty data for note $i in '$folder_name', skipping"
            ERRORS=$((ERRORS + 1))
            i=$((i + 1))
            continue
        fi

        # Parse fields using awk with multi-char delimiter
        NOTE_NAME=$(echo "$NOTE_DATA" | awk 'BEGIN{FS="<<FIELD_SEP>>"}{print $1}')
        NOTE_BODY=$(echo "$NOTE_DATA" | awk 'BEGIN{FS="<<FIELD_SEP>>"}{print $2}')
        NOTE_DATE=$(echo "$NOTE_DATA" | awk 'BEGIN{FS="<<FIELD_SEP>>"}{print $3}')

        # Check if already tagged
        ALREADY_TAGGED=false
        if echo "$NOTE_BODY" | grep -q "#claudewashere"; then
            ALREADY_TAGGED=true
            SKIPPED=$((SKIPPED + 1))
            log "  Already tagged: '$NOTE_NAME' -- extracting but not re-tagging"
        fi

        # Classify
        NOTE_TYPE=$(classify_note "$NOTE_NAME" "$NOTE_BODY")

        # Append to MD output
        {
            echo "---"
            echo "TYPE: $NOTE_TYPE"
            echo "SOURCE: Apple Notes"
            echo "FOLDER: $folder_name"
            echo "TITLE: $NOTE_NAME"
            echo "DATE: $NOTE_DATE"
            if [ "$ALREADY_TAGGED" = true ]; then
                echo "TAGGED: already"
            fi
            echo "---"
            echo "$NOTE_BODY"
            echo ""
            echo "$SEPARATOR"
            echo ""
        } >> "$OUTPUT_MD"

        # Append to CSV
        PREVIEW=$(echo "$NOTE_BODY" | head -c 200 | tr '\n' ' ' | tr '\r' ' ')
        FULL_CONTENT=$(echo "$NOTE_BODY" | tr '\n' ' ' | tr '\r' ' ')
        {
            printf '%s,%s,%s,%s,%s\n' \
                "$(escape_csv "$NOTE_TYPE")" \
                "$(escape_csv "$NOTE_NAME")" \
                "$(escape_csv "$NOTE_DATE")" \
                "$(escape_csv "$PREVIEW")" \
                "$(escape_csv "$FULL_CONTENT")"
        } >> "$OUTPUT_CSV"

        # Tag the note (APPEND ONLY) if not already tagged
        if [ "$ALREADY_TAGGED" = false ]; then
            osascript << ENDTAG 2>/dev/null || log "  WARNING: Could not tag note '$NOTE_NAME'"
                tell application "Notes"
                    try
                        set f to folder "$folder_name"
                        set n to note $i of f
                        set currentBody to body of n
                        set body of n to currentBody & "<br><br>#claudewashere"
                    end try
                end tell
ENDTAG
        fi

        TOTAL=$((TOTAL + 1))
        increment_type "$NOTE_TYPE"

        log "  OK: '$NOTE_NAME' -> $NOTE_TYPE $([ "$ALREADY_TAGGED" = true ] && echo '[already tagged]' || echo '[tagged]')"

        # Small delay to not hammer Notes.app
        sleep 0.3
        i=$((i + 1))
    done
done

# ============================================================
# STEP 3: Summary
# ============================================================
log ""
log "=========================================="
log "EXTRACTION COMPLETE"
log "=========================================="
log "Total notes processed: $TOTAL"
log "Already tagged (skipped re-tag): $SKIPPED"
log "Errors: $ERRORS"
log ""
log "By type:"
[ $COUNT_CAPTION -gt 0 ]    && log "  CAPTION: $COUNT_CAPTION"
[ $COUNT_QUOTE -gt 0 ]      && log "  QUOTE: $COUNT_QUOTE"
[ $COUNT_BOOK_DRAFT -gt 0 ] && log "  BOOK_DRAFT: $COUNT_BOOK_DRAFT"
[ $COUNT_POEM -gt 0 ]       && log "  POEM: $COUNT_POEM"
[ $COUNT_IDEA -gt 0 ]       && log "  IDEA: $COUNT_IDEA"
[ $COUNT_EMAIL -gt 0 ]      && log "  EMAIL: $COUNT_EMAIL"
[ $COUNT_CONTENT -gt 0 ]    && log "  CONTENT: $COUNT_CONTENT"
log ""
log "Output files:"
log "  MD:  $OUTPUT_MD"
log "  CSV: $OUTPUT_CSV"
log "  LOG: $LOG"

# Append summary to MD file
{
    echo ""
    echo "# EXTRACTION SUMMARY"
    echo "Total notes: $TOTAL"
    echo "Already tagged: $SKIPPED"
    echo "Errors: $ERRORS"
    echo ""
    [ $COUNT_CAPTION -gt 0 ]    && echo "- CAPTION: $COUNT_CAPTION"
    [ $COUNT_QUOTE -gt 0 ]      && echo "- QUOTE: $COUNT_QUOTE"
    [ $COUNT_BOOK_DRAFT -gt 0 ] && echo "- BOOK_DRAFT: $COUNT_BOOK_DRAFT"
    [ $COUNT_POEM -gt 0 ]       && echo "- POEM: $COUNT_POEM"
    [ $COUNT_IDEA -gt 0 ]       && echo "- IDEA: $COUNT_IDEA"
    [ $COUNT_EMAIL -gt 0 ]      && echo "- EMAIL: $COUNT_EMAIL"
    [ $COUNT_CONTENT -gt 0 ]    && echo "- CONTENT: $COUNT_CONTENT"
    echo ""
    echo "Generated: $(date)"
} >> "$OUTPUT_MD"

# File sizes
MD_SIZE=$(du -h "$OUTPUT_MD" | cut -f1)
CSV_SIZE=$(du -h "$OUTPUT_CSV" | cut -f1)
log "File sizes: MD=$MD_SIZE, CSV=$CSV_SIZE"
log "DONE."
